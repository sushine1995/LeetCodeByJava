/** 
* @author  suzw
* @version 创建时间：2018年10月18日 下午3:29:33 
* 类说明 
* 1. 注意异或的性质： x ^ x = 0, x^0 = x
* 2. 注意输入的k从1开始，而讨论时是从0开始
* 思路：
* 1. 第L个字符产生下一行的第2L和2L+1个字符【注意，这里的L是从0开始，而K是从1开始】
* 2. 第2L个字符和上一行的第L个字符相同
* 3.结果和第几行无关，可以发现，第i行是第i+1行的前半部分
* 4. 用f(k)表示第k个字符的值，可以找到以下关系：
* 	f(2*k) = f（k)  = 0(if f(k)=0),1(if f(k)=1)  = f(k) xor 0(异或的性质)；
* 	f(2*k+1) = 0(if f(k)=1),1 (if f(k)= 0 ) = f(k) xor 1
* 5. 将k用二进制表示，如K = 1001010，则k/2 = 100101, k/4 = 10010+1
* 	f(k) = f(1001010) = f(100101) ^0 = f(10010)^1 ^0 = f (1001)^0 ^1 ^0 = f(100)^1 ^0 ^1 ^0
* 		 =f(1)^0 ^ 0 ^1 ^0 ^1 ^0 
* 	f(k+1) = f(1)^0 ^ 0 ^1 ^0 ^1 ^1
* 6. f(1)=f(0 +1) =f(0)^1,所以f(k) = f(0) ^1 ^0 ^ 0 ^1 ^0 ^1 ^0 =1^1^1
* 	实际上就是统计二进制数k中包含1的个数，
*   因为上面推导中的K是从0开始的，输入的k是从1开始的，所以最后的结果是Integer.bitCount(K-1) & 1;
* 7. 变形: 如果从1开始变形呢？  需要从6开始改变，f(0)就是1，和现在比，多和一个1进行与操作
* 
* 在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。
给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）
例子:
输入: N = 1, K = 1
输出: 0
输入: N = 2, K = 1
输出: 0
输入: N = 2, K = 2
输出: 1
输入: N = 4, K = 5
输出: 1
解释:
第一行: 0
第二行: 01
第三行: 0110
第四行: 01101001
注意：
N 的范围 [1, 30].
K 的范围 [1, 2^(N-1)].
*/
public class _779_Kth_Symbol_In_Grammar_10变形的第k个字符 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}
	
	public int kthGrammar(int N, int K) {
	    return Integer.bitCount(K-1) & 1;
	}
	
	
}
